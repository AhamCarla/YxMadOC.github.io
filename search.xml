<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JPA提供的save方法实现的初步解析]]></title>
    <url>%2F2019%2F08%2F03%2FJPA%E6%8F%90%E4%BE%9B%E7%9A%84save%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Based on Spring version: 2.1.6.RELEASE 在使用Spring Data JPA时，通常会觉得这个框架很神奇，几乎为0的SQL代码量，实现几个简单的接口，并在其中自定义要执行查询的方法名，便可实现CRUD操作。本文将对最常用的方法之一——save方法的源码实现作简单的解析，对一些详细的实现细节暂不作讨论。 Repository要使用Spring Data JPA，除了要定义实体，还有一件必须做的事情就是创建Repository接口，并继承JPA提供的JpaRepository接口了，在继承该接口时，我们会定义该接口所管理的实体类型以及实体的ID数据类型。 CrudRepository往上追溯JpaRepository会发现，该接口又继承了PagingAndSortingRepository和QueryByExampleExecutor接口，QueryByExampleExecutor是通过Example执行条件查询的执行器，本文不作讨论。继续追溯PagingAndSortingRepository接口，发现其又继承了CrudRepository接口，通过阅读其中定义的方法，可以得知该接口是JPA所有Repository的最基本的方法定义（增删查改）。 SimpleJpaRepository在CrudRepository中，我们发现了该接口的唯一实现类：SimpleJpaRepository，在该类中我们找到了save的实现： 12345678910@Transactionalpublic &lt;S extends T&gt; S save(S entity) &#123; if (entityInformation.isNew(entity)) &#123; em.persist(entity); return entity; &#125; else &#123; return em.merge(entity); &#125;&#125; 从此不难看出，save方法神奇的地方：“不存在则新增，存在则更新”的实现原理。该方法通过调用entityInformation的isNew方法，判断该实体是否为新实体，若是则执行EntityManager的persist方法（新增操作），反之则执行merge方法（更新操作）。 EntityInformation顾名思义，EntityInformation是提供实体信息的工具，在SimpleJpaRepository中作为构造器参数被传入。在本文的实验情况中，程序调用了该类的实现类JpaMetamodelEntityInformation，该类实现了isNew方法： 123456789101112@Overridepublic boolean isNew(T entity) &#123; if (!versionAttribute.isPresent() || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive).orElse(false)) &#123; return super.isNew(entity); &#125; BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity); return versionAttribute.map(it -&gt; wrapper.getPropertyValue(it.getName()) == null).orElse(true);&#125; 上述代码中的versionAttribute属性是有关数据库乐观锁的实现，由于本文的测试数据并没有定义version列，故不作讨论。该方法中调用了父类AbstractEntityInformation的isNew实现，在该父类实现中，判断是否为新实体的逻辑较为清晰： 123456789101112131415public boolean isNew(T entity) &#123; ID id = getId(entity); Class&lt;ID&gt; idType = getIdType(); if (!idType.isPrimitive()) &#123; return id == null; &#125; if (id instanceof Number) &#123; return ((Number) id).longValue() == 0L; &#125; throw new IllegalArgumentException(String.format(&quot;Unsupported primitive id type %s!&quot;, idType));&#125; 该方法先是提取了当前实体的ID与ID类型，在判断其是否为包装类型，若是包装类型，继续判断id是否为null，若是，则为新实体。 EntityManagerEntityManager接口是JPA标准的体现，在这里定义了各种对数据的操作行为，如persist, merge, find等，Hibernate提供的该接口的实现类是SessionImpl。Hibernate在此实现了EntityManager的行为，对于save方法，主要涉及到的就是persist和merge两个方法，这两个方法有多种重载，下面只涉及其中的一种。 persistpersist方法的实现如下： 12345@Overridepublic void persist(Object object) throws HibernateException &#123; checkOpen(); firePersist( new PersistEvent( null, object, this ) );&#125; 在方法体中，checkOpen()方法是检测当前数据库会话是否打开，实现的关键是firePersist方法，该方法的参数是Hibernate封装的PersistEvent类。PersistEvent封装了当前传入的实体以及数据源信息，为firePersist方法提供了执行操作所必要的条件。在更深层的firePesist方法，Hibernate进行了更为细节的操作，如检查事务，懒加载实现，与数据库交互等，其中使用了较多设计模式，解析起来比较复杂。 mergemerge方法的实现如下： 12345@Overridepublic Object merge(Object object) throws HibernateException &#123; checkOpen(); return fireMerge( new MergeEvent( null, object, this ));&#125; merge方法以及fireMerge方法的实现与persist类似。 总结可以看出，对于传入save方法的实体执行新增操作还是更新操作，Spring Data只是简单地判断了该实体的ID是否为空。相比persist操作，merge操作的实现还是比较复杂，希望以后能弄明白onPersist等方法的执行逻辑。]]></content>
      <tags>
        <tag>Backend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速推CI/CD]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%9F%E6%8E%A8CI-CD%2F</url>
    <content type="text"><![CDATA[本文归档了进行CI/CD搭建的快速指南。 ENV Jenkins目录：/var/lib/jenkins 其他工具统一安装在: /opt 使用永久环境变量配置方法：12345678vi /etc/profile#在最后写入工具名_HOME=工具目录export PATH=$PATH:$&#123;工具名_HOME&#125;#保存并退出后执行source /etc/profile bt.cn宝塔是一个Linux/Windows服务器管理工具。 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 安装完宝塔，依据用户选择，宝塔会自动安装MySQL, Apache等应用。 Apache配置在配置文件末尾（在声明体内）加上 ProxyPass /api http://localhost:8090 JDK安装指令： yum install java-1.8.0-openjdk-devel 若有多个Java环境，使用下面的命令切换： alternatives –config java Gradle1234sudo mkdir /opt/gradlesudo unzip -d /opt/gradle gradle-5.5.1-bin.zip#配置环境变量gradle -v Jenkins12345wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat-stable/jenkins.reporpm --import http://pkg.jenkins.io/redhat-stable/jenkins.io.keyyum install jenkinssystemctl start jenkinssystemctl enable jenkins 下面是Jenkins Pipeline工程的Jenkinsfile案例。 Jenkins Pipeline Example12345678910111213141516171819202122232425node &#123; def gradleHome = tool &apos;gradle5.5.1&apos; env.PATH = &quot;$&#123;gradleHome&#125;:$&#123;env.PATH&#125;&quot; stage(&apos;Checkout&apos;) &#123; echo &apos;Checkout&apos; checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/master&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;581b6b7c-8b09-45ef-b1eb-e6e567b1582b&apos;, url: &apos;https://github.com/YxMadOC/ita-final&apos;]]]) &#125; stage(&apos;Build&apos;) &#123; echo &apos;Building&apos; sh &apos;gradle clean build&apos; &#125; stage(&apos;Test&apos;) &#123; echo &apos;Testing&apos; sh &apos;gradle test&apos; &#125; stage(&apos;Deploy&apos;) &#123; echo &apos;Deploying&apos; sh &apos;gradle bootJar&apos; sh &apos;chmod +x stop.sh&apos; sh &apos;./stop.sh&apos; withEnv([&apos;JENKINS_NODE_COOKIE=background_job&apos;]) &#123; sh &apos;nohup java -jar build/libs/ita-final-0.0.1-SNAPSHOT.jar &gt; log.txt 2&gt;&amp;1 &amp;&apos; &#125; &#125;&#125; Remote Deploy Example远程部署使用了SSH Pipeline Steps插件 123456789101112131415161718192021222324252627282930node &#123; def gradleHome = tool &apos;gradle5.5.1&apos; env.PATH = &quot;$&#123;gradleHome&#125;:$&#123;env.PATH&#125;&quot; def remote = [:] def remotePath = &apos;/opt/ita-final&apos; remote.name = &apos;qcloud&apos; remote.host = &apos;134.175.84.46&apos; remote.user = &apos;root&apos; remote.password = &apos;ZHA-ITA-2019&apos; remote.allowAnyHosts = true stage(&apos;Checkout&apos;) &#123; echo &apos;Checkout&apos; checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/master&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;581b6b7c-8b09-45ef-b1eb-e6e567b1582b&apos;, url: &apos;https://github.com/YxMadOC/ita-final&apos;]]]) &#125; stage(&apos;Build&apos;) &#123; echo &apos;Building&apos; sh &apos;gradle clean build&apos; &#125; stage(&apos;Test&apos;) &#123; echo &apos;Testing&apos; sh &apos;gradle test&apos; &#125; stage(&apos;Deploy&apos;) &#123; echo &apos;Deploying&apos; sh &apos;gradle bootJar&apos; sshScript remote: remote, script: &apos;stop.sh&apos; sshPut remote: remote, from: &apos;build/libs/ita-final-0.0.1-SNAPSHOT.jar&apos;, into: remotePath sshScript remote: remote, script: &apos;start.sh&apos; &#125;&#125;]]></content>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brief Introduction of Gradle]]></title>
    <url>%2F2019%2F07%2F20%2FBrief-Introduction-of-Gradle%2F</url>
    <content type="text"><![CDATA[本文只介绍Gradle于Java项目上的应用。 What is Gradle?Gradle与Ant、Maven一样，是一种构建工具，能自动化执行项目构建，并提供依赖管理的功能。与Ant、Maven相比，因为Gradle不像Maven那样为用户强行定义了项目周期，并且能自定义构建任务，所以Gradle具有更大的灵活性。 Gradle for Java ProjectsGradle使用了约定优于配置的原则来构建基于JVM的项目，其中有些约定参考了Apache Maven。尤其是使用了与Maven项目相同的项目结构，并且Gradle可以兼容Maven仓库。 Convention-Over-ConfigurationConvention-Over-Configuration即约定优于配置，以Gradle中的Java支持插件为例： 得益于Java插件，你将可以执行以下任务： compileTask： 用于编译 src/main/java 下的所有Java源文件 compileTestJava： 用于编译 src/test/java 下的所有Java源文件 test：用于执行 src/test/java 下的所有测试 jar: 将 main 目录下的所有已编译文件以及 src/main/resources 下的资源文件打包成&lt;项目名&gt;-&lt;版本号&gt;.jar javadoc：将生成main目录下的所有文档 上面提到的目录，如 src/main/java 和 src/test/java 以及 src/main/resources 都是Gradle约定优于配置原则的直接体现。当然，你也可以定义自己的Source目录，但除非有特殊需要，平时并不建议这么做。 除Gradle之外，许多框架（如Spring Boot）也采用了这种原则，目的是为了方便开发者专注于开发，而不是花时间在繁琐的配置之上。 build.gradle类似Maven中的pom.xml，Gradle通过build.gradle来定义构建任务以及引入依赖。下面是一个常见的build.gradle示例： 1234567891011121314151617181920212223242526272829303132333435363738394041buildscript &#123; ext &#123; springBootVersion = &apos;2.0.3.RELEASE&apos; &#125; repositories &#123; mavenCentral() maven &#123; url &quot;https://plugins.gradle.org/m2/&quot; &#125; &#125; dependencies &#123; classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot; classpath &apos;org.junit.platform:junit-platform-gradle-plugin:1.0.0&apos; &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;idea&apos;apply plugin: &apos;org.springframework.boot&apos;apply plugin: &apos;io.spring.dependency-management&apos;apply plugin: &apos;org.junit.platform.gradle.plugin&apos;group = &apos;com.tw&apos;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile &apos;org.springframework.boot:spring-boot-starter-actuator&apos; compile &apos;org.springframework.boot:spring-boot-starter-web&apos; compile &apos;org.springframework.boot:spring-boot-starter-data-jpa&apos; runtime &apos;com.h2database:h2:1.4.199&apos; compile &apos;org.projectlombok:lombok:1.18.8&apos; compile &apos;org.flywaydb:flyway-core:5.2.4&apos; testCompile &apos;org.springframework.boot:spring-boot-starter-test&apos; testImplementation(&apos;org.junit.jupiter:junit-jupiter-api:5.0.0&apos;) testCompile(&apos;org.junit.jupiter:junit-jupiter-params:5.0.0&apos;) testRuntime(&apos;org.junit.jupiter:junit-jupiter-engine:5.0.0&apos;)&#125; buildScripts在许多Gradle脚本中，经常能看见： 1234567891011121314151617buildscript &#123; ext &#123; springBootVersion = &apos;2.0.3.RELEASE&apos; &#125; repositories &#123; mavenCentral() maven &#123; url &quot;https://plugins.gradle.org/m2/&quot; &#125; &#125; dependencies &#123; classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot; classpath &apos;org.junit.platform:junit-platform-gradle-plugin:1.0.0&apos; &#125;&#125;repositories &#123; mavenCentral()&#125; 为什么要定义两次repositories，甚至dependencies？他们有什么不同？ 其实，buildScripts是Gradle脚本本身所需要使用的依赖，因为Gradle脚本是基于Groovy DSL的，可以在脚本中引入第三方的库，就像我们编写Java代码一样。另外，Gradle提供了一些开箱即用的任务，更多丰富的任务需要依赖第三方的插件，buildScript为这些第三方插件进行了元描述，定义了这些插件的ID，仓库源等，而buildScript外部的配置才是我们项目本身相关的配置。 Plugins12345apply plugin: &apos;java&apos;apply plugin: &apos;idea&apos;apply plugin: &apos;org.springframework.boot&apos;apply plugin: &apos;io.spring.dependency-management&apos;apply plugin: &apos;org.junit.platform.gradle.plugin&apos; plugins指的是Gradle中各种第三方插件，有了这些开箱即用的插件，我们可以省去许多配置。比如我们熟悉的gradle bootRun 以及 gradle flyway等都是由插件提供的快捷指令。 Project Info123group = &apos;com.tw&apos;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8 上面三行是项目的相关信息，可以定义项目的组名、版本号、Java版本、名称等，更多项目信息配置项可以参考官方文档。 Repositories123repositories &#123; mavenCentral()&#125; 这里定义的是依赖仓库地址，Gradle项目中默认会使用Maven中央仓库，但是这个仓库由于一些不可抗力的原因，能让一个小项目的Sync时间高达半个小时。所以这里建议换成国内的仓库地址： 1maven &#123;url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;&#125; Dependencies12345678910111213dependencies &#123; implementation &apos;org.springframework.boot:spring-boot-starter-actuator&apos; implementation &apos;org.springframework.boot:spring-boot-starter-web&apos; implementation &apos;org.springframework.boot:spring-boot-starter-data-jpa&apos; runtimeOnly &apos;com.h2database:h2:1.4.199&apos; implementation &apos;org.projectlombok:lombok:1.18.8&apos; implementation &apos;org.flywaydb:flyway-core:5.2.4&apos; testImplementation &apos;org.springframework.boot:spring-boot-starter-test&apos; testImplementation(&apos;org.junit.jupiter:junit-jupiter-api:5.0.0&apos;) testImplementation(&apos;org.junit.jupiter:junit-jupiter-params:5.0.0&apos;) testRuntimeOnly(&apos;org.junit.jupiter:junit-jupiter-engine:5.0.0&apos;)&#125; 这里是Gradle的依赖管理部分，与Maven一样，Gradle也提供了几种常用的依赖作用范围： compileOnly: 标注用于编译项目但不应该成为运行时环境的依赖 implementation (替换 compile)：标注用于项目编译过程以及运行时的依赖 runtimeOnly (替换 runtime)：标注只用于项目运行时的依赖除此之外，还有 testCompileOnly, testImplementation 和 testRuntimeOnly，这三种与上面的并没有什么不同，只是他们作用于测试环境。 Tips在Gradle中遇到如下常见问题，可以参考下面的方法解决： IDEA未识别Gradle项目通常情况下，IDEA会自动把有build.gradle文件的项目识别为gradle项目，并且在index完成后会在右下角提示，要是手贱点掉了那个提示，可以通过以下方式解决： 右键项目 -&gt; Open Module Settings -&gt; Facets -&gt; + -&gt; Java-Gradle -&gt; 选中项目目录 项目引入慢 maven {url ‘http://maven.aliyun.com/nexus/content/groups/public/&#39;} 引入了依赖却无法引用可能是引入依赖后没有Sync项目导致。可以打开IDEA最右边的Gradle选项卡，如果你没有找到，可以找到IDEA的顶部选项卡 View -&gt; Tool Window Bars，如果打开了还是没有，请查看该项目是不是已经被IDEA识别为Gradle项目。在打开Gradle选项卡后，选项卡左上角有个刷新图标，点击即可刷新项目引入依赖。在这里推荐打开Auto-Import，右键选项卡中的项目名称即可找到该选项。 若刷新项目后，还是无法引用依赖，请检查依赖的名称以及版本号是否有错误。可以到选项卡中的Source Sets检查。]]></content>
      <tags>
        <tag>Backend</tag>
      </tags>
  </entry>
</search>
